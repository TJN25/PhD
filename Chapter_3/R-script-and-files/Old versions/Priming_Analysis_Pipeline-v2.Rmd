---
title: "CRISPR-Cas Systems analysis"
author: "Thomas Nicholson"
date: "2/9/2017"
output: pdf_document
---

I don't think all of these libraries are needed.
##setwd() is run in this chunk

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

##load packages
library(xtable)
library(stringr)
library(plyr)
library(devtools)
library(dplyr)
library(tidyr)
library(EMT)


setwd("~/Desktop/Project/Working/")

##Looks at the quadrant distribution. It only needs swipeData and a subtype to run.
quadrant_analysis <- function(dat, Subtype.label, use.all.hits = F){
 if(use.all.hits){ 
   IFData <- dat%>%filter(Subtype == Subtype.label)%>%filter(spacer.order.number >= 2)
 }else if(use.all.hits == F){
      IFData <- dat%>%filter(Subtype == Subtype.label)%>%filter(spacer.order.number == 2 | spacer.order.number == 3)

 }
  
IFData <- IFData%>%mutate(tmp = paste(target.strand, five.three.prime.dir, sep = "_"))
quadrants <- as.data.frame(table(IFData$tmp))
total <- sum(quadrants$Freq)
quadrants <- quadrants%>%mutate(percentage = round(Freq/total*100, 2))
strands <- as.data.frame(table(IFData$target.strand))
strands <- strands%>%mutate(percentage = round(Freq/total*100, 2))
mat <- matrix(c(round(quadrants[4,2]), round(quadrants[3,2]),round(quadrants[1,2]), round(quadrants[2,2]) ), nrow = 2, byrow = T)
   # mat <- matrix(c(38,28,17,31), nrow = 2, byrow = T)

# mat.res <- fisher.test(mat)
quadrants <- quadrants%>%mutate(rowNum = c(3,4,1,2))%>%arrange(rowNum)%>%select(-rowNum)
mat.res <- multinomial.test(observed = quadrants$Freq, prob = c(0.25, 0.25, 0.25, 0.25), MonteCarlo = T, ntrial = 10000000)


print(paste("Host-Target pairs:", length(unique(IFData$host.target.pair))))
print(paste("Quadrant p-value:",round(mat.res$p.value, 4)))
# print(mat.res$p.value)
print(strands)
print(quadrants)

}
##takes swipeData and produces a random distribution for all subtypes in the swipeData
generate_random_distribution <- function(swipeData){
  ##generate the random dataset
set.seed(100)

##generate dataset with 100 replicates
targets.dat.replicated <- swipeData[rep(seq_len(nrow(swipeData)), 100), ]

##randomly assign protospacer site and strand
rh <- targets.dat.replicated%>%
  mutate(distance.to.protospacer = runif(min = -0.5, max = 0.5, n = nrow(targets.dat.replicated)))%>%
  mutate(distance.to.protospacer = round(distance.to.protospacer*genome.length, 0))%>%
  mutate(distance.to.protospacer = ifelse(spacer.order.number == 1, 0, distance.to.protospacer))%>%
  mutate(target.strand = round(runif(min = 0, max = 1, n = nrow(targets.dat.replicated)), 0))%>%
  mutate(target.strand = ifelse(target.strand == 1, "t", "n"))%>%
  mutate(five.three.prime.dir = ifelse(distance.to.protospacer < 0, ifelse(target.strand == "t", 5, 3), ifelse(target.strand == "t", 3, 5)))%>%
  mutate(strand.plus.direction = paste(target.strand, five.three.prime.dir, sep = "_"))%>%
  mutate(target.pos = runif(min = 0, max = 1, n = nrow(targets.dat.replicated)))%>%
  mutate(target.pos = round(target.pos*genome.length, 0))

rm(targets.dat.replicated)

##assign replicates into groups
rh <- rh%>%arrange(unique.spacer.target.match)%>%mutate(group.number = rep(1:10, 10*nrow(swipeData)))

return(rh)
}  



generate_random_quadrants <- function(swipeData){
  ##generate the random dataset
set.seed(100)

##generate dataset with 100 replicates
targets.dat.replicated <- swipeData[rep(seq_len(nrow(swipeData)), 100), ]

##randomly assign protospacer site and strand
rh <- targets.dat.replicated%>%
  mutate(distance.to.protospacer = abs(distance.to.protospacer))%>%
  mutate(target.strand = round(runif(min = 0, max = 1, n = nrow(targets.dat.replicated)), 0))%>%
  mutate(target.strand = ifelse(target.strand == 1, "t", "n"))%>%
  mutate(five.three.prime.dir = round(runif(min = 0, max = 1, n = nrow(targets.dat.replicated)), 0))%>%
  mutate(five.three.prime.dir = ifelse(five.three.prime.dir == 1, "5", "3"))%>%
  mutate(distance.to.protospacer = ifelse(five.three.prime.dir == "5" & target.strand == "t", -distance.to.protospacer, ifelse(five.three.prime.dir == "3" & target.strand == "n", -distance.to.protospacer, distance.to.protospacer)))%>%
  mutate(strand.plus.direction = paste(target.strand, five.three.prime.dir, sep = "_"))

rm(targets.dat.replicated)

##assign replicates into groups
rh <- rh%>%arrange(unique.spacer.target.match)%>%mutate(group.number = rep(1:10, 10*nrow(swipeData)))

return(rh)
}  


##takes the swipeData, random data and a subtype and generates a distribution table for plotting (this is done elsewhere)
protospacer_distribution <- function(swipeData, rh, Subtype.label){
  ## Setup #####
  ##input variables
  binwidth <- 150
  smoothing.val <- 150
  xlim.num <- 10000
  
##select the random data for a given subtype
sr <- rh%>%filter(Subtype == Subtype.label)%>%filter(spacer.order.number > 1)

##label the data as random and include the group number
sr <- sr%>%mutate(data.type = paste("random", group.number, sep = "_"))%>%
  mutate(data.type = ifelse(data.type == "random_1", "random_01", data.type))

##select the data that will be needed for determining posisiton
sr <- sr%>%select(distance.to.protospacer, data.type, strand.plus.direction)
    


st <- swipeData%>%filter(Subtype == Subtype.label)%>%filter(spacer.order.number > 1)


##label the data as target
st <- st%>%mutate(data.type = "targets")%>%
      mutate(strand = ifelse(strand.plus.direction == "n_5", "n", ifelse(strand.plus.direction == "n_3", "n", "t")))%>%
      select(-strand)

##select the data that will be needed for determining posisiton
st <- st%>%select(distance.to.protospacer, data.type, strand.plus.direction)


## Calculate densities #####
##combine the random and real data
D = rbind(sr, st) 
  

##select the quadrant  
n_3.den <- D%>%filter(grepl("n_", strand.plus.direction))  %>% 
      group_by(data.type) %>% 
## calculate densities for each group over same range; store in list column
      summarise(d = list(density(distance.to.protospacer, from = -xlim.num, to = 0, n = xlim.num/binwidth, bw = smoothing.val))) %>% 
## make a new data.frame from two density objects
      do(data.frame(distance.breaks.short = .$d[[1]]$x,    # grab one set of x values (which are the same)
                    density.values.random_1 = .$d[[1]]$y,
                    density.values.random_10 = .$d[[2]]$y,
                    density.values.random_2 = .$d[[3]]$y,
                    density.values.random_3 = .$d[[4]]$y,
                    density.values.random_4 = .$d[[5]]$y,
                    density.values.random_5 = .$d[[6]]$y,
                    density.values.random_6 = .$d[[7]]$y,
                    density.values.random_7 = .$d[[8]]$y,
                    density.values.random_8 = .$d[[9]]$y,
                    density.values.random_9 = .$d[[10]]$y,
                    density.values.targets = .$d[[11]]$y))# %>%    # and subtract the y values

##select the quadrant  
    n_5.den <- D%>%filter(grepl("n_", strand.plus.direction))%>% 
      group_by(data.type) %>% 
## calculate densities for each group over same range; store in list column
      summarise(d = list(density(distance.to.protospacer, from = 0, to = xlim.num, n = xlim.num/binwidth, bw = smoothing.val))) %>% 
## make a new data.frame from two density objects
      do(data.frame(distance.breaks.short = .$d[[1]]$x,    # grab one set of x values (which are the same)
                    density.values.random_1 = .$d[[1]]$y,
                    density.values.random_10 = .$d[[2]]$y,
                    density.values.random_2 = .$d[[3]]$y,
                    density.values.random_3 = .$d[[4]]$y,
                    density.values.random_4 = .$d[[5]]$y,
                    density.values.random_5 = .$d[[6]]$y,
                    density.values.random_6 = .$d[[7]]$y,
                    density.values.random_7 = .$d[[8]]$y,
                    density.values.random_8 = .$d[[9]]$y,
                    density.values.random_9 = .$d[[10]]$y,
                    density.values.targets = .$d[[11]]$y))# %>%    # and subtract the y values

##select the quadrant  
    t_3.den <- D%>%filter(grepl("t_", strand.plus.direction))%>% 
      group_by(data.type) %>% 
## calculate densities for each group over same range; store in list column
      summarise(d = list(density(distance.to.protospacer, from = 0, to = xlim.num, n = xlim.num/binwidth, bw = smoothing.val))) %>% 
## make a new data.frame from two density objects
      do(data.frame(distance.breaks.short = .$d[[1]]$x,    # grab one set of x values (which are the same)
                    density.values.random_1 = .$d[[1]]$y,
                    density.values.random_10 = .$d[[2]]$y,
                    density.values.random_2 = .$d[[3]]$y,
                    density.values.random_3 = .$d[[4]]$y,
                    density.values.random_4 = .$d[[5]]$y,
                    density.values.random_5 = .$d[[6]]$y,
                    density.values.random_6 = .$d[[7]]$y,
                    density.values.random_7 = .$d[[8]]$y,
                    density.values.random_8 = .$d[[9]]$y,
                    density.values.random_9 = .$d[[10]]$y,
                    density.values.targets = .$d[[11]]$y))# %>%    # and subtract the y values
    
##select the quadrant  
    t_5.den <- D%>%filter(grepl("t_", strand.plus.direction))%>% 
      group_by(data.type) %>% 
## calculate densities for each group over same range; store in list column
      summarise(d = list(density(distance.to.protospacer, from = -xlim.num, to = 0, n = xlim.num/binwidth, bw = smoothing.val))) %>% 
## make a new data.frame from two density objects
      do(data.frame(distance.breaks.short = .$d[[1]]$x,    # grab one set of x values (which are the same)
                    density.values.random_1 = .$d[[1]]$y,
                    density.values.random_10 = .$d[[2]]$y,
                    density.values.random_2 = .$d[[3]]$y,
                    density.values.random_3 = .$d[[4]]$y,
                    density.values.random_4 = .$d[[5]]$y,
                    density.values.random_5 = .$d[[6]]$y,
                    density.values.random_6 = .$d[[7]]$y,
                    density.values.random_7 = .$d[[8]]$y,
                    density.values.random_8 = .$d[[9]]$y,
                    density.values.random_9 = .$d[[10]]$y,
                    density.values.targets = .$d[[11]]$y))# %>%    # and subtract the y values
    
    n_3.den <- n_3.den%>%mutate(strand.plus.direction = "n_3")
    n_5.den <- n_5.den%>%mutate(strand.plus.direction = "n_5")
    t_3.den <- t_3.den%>%mutate(strand.plus.direction = "t_3")
    t_5.den <- t_5.den%>%mutate(strand.plus.direction = "t_5")
    

    den <- rbind(n_3.den, n_5.den, t_3.den, t_5.den)

    
    
    rDen1 <- den%>%mutate(density.values = density.values.random_1)%>%select(distance.breaks.short, density.values, strand.plus.direction)%>%mutate(group =  "random_1")%>%mutate(group.main =  "random")
    
    rDen2 <- den%>%mutate(density.values = density.values.random_2)%>%select(distance.breaks.short, density.values, strand.plus.direction)%>%mutate(group =  "random_2")%>%mutate(group.main =  "random")
    
    rDen3 <- den%>%mutate(density.values = density.values.random_3)%>%select(distance.breaks.short, density.values, strand.plus.direction)%>%mutate(group =  "random_3")%>%mutate(group.main =  "random")
    
    rDen4 <- den%>%mutate(density.values = density.values.random_4)%>%select(distance.breaks.short, density.values, strand.plus.direction)%>%mutate(group =  "random_4")%>%mutate(group.main =  "random")
    
    rDen5 <- den%>%mutate(density.values = density.values.random_5)%>%select(distance.breaks.short, density.values, strand.plus.direction)%>%mutate(group =  "random_5")%>%mutate(group.main =  "random")
    
    rDen6 <- den%>%mutate(density.values = density.values.random_6)%>%select(distance.breaks.short, density.values, strand.plus.direction)%>%mutate(group =  "random_6")%>%mutate(group.main =  "random")
    
    rDen7 <- den%>%mutate(density.values = density.values.random_7)%>%select(distance.breaks.short, density.values, strand.plus.direction)%>%mutate(group =  "random_7")%>%mutate(group.main =  "random")
    
    rDen8 <- den%>%mutate(density.values = density.values.random_8)%>%select(distance.breaks.short, density.values, strand.plus.direction)%>%mutate(group =  "random_8")%>%mutate(group.main =  "random")
    
    rDen9 <- den%>%mutate(density.values = density.values.random_9)%>%select(distance.breaks.short, density.values, strand.plus.direction)%>%mutate(group =  "random_9")%>%mutate(group.main =  "random")
    
    rDen10 <- den%>%mutate(density.values = density.values.random_10)%>%select(distance.breaks.short, density.values, strand.plus.direction)%>%mutate(group =  "random_10")%>%mutate(group.main =  "random")
    
    
    tDen <- den%>%mutate(density.values = density.values.targets)%>%select(distance.breaks.short, density.values, strand.plus.direction)%>%mutate(group =  "targets")%>%mutate(group.main =  "targets")
    
    den <- rbind(rDen1,rDen2,rDen3,rDen4,rDen5,rDen6,rDen7,rDen8,rDen9,rDen10, tDen)
    
    den <- den%>%arrange(distance.breaks.short)
    
    
    sdrandomDensity <- den%>%filter(group.main == "random")%>%group_by(distance.breaks.short, strand.plus.direction)%>%summarise(sdDensity = sd(density.values))%>%mutate(breaksStrandDirection = paste(distance.breaks.short, strand.plus.direction, sep = "$"))%>%ungroup()%>%select(-strand.plus.direction, - distance.breaks.short)
    meanrandomDensity <- den%>%filter(group.main == "random")%>%group_by(distance.breaks.short, strand.plus.direction)%>%summarise(meanDensity = mean(density.values))%>%mutate(breaksStrandDirection = paste(distance.breaks.short, strand.plus.direction, sep = "$"))
    randomDensity <- left_join(sdrandomDensity, meanrandomDensity, by = "breaksStrandDirection")
    
    randomDensity <- randomDensity%>%mutate(upperRandomDensity = meanDensity + 2*sdDensity)%>%mutate(lowerRandomDensity = meanDensity - 2*sdDensity)
    targetDensity <- den%>%filter(group == "targets")
    
    upperRandomDensityValues <- randomDensity%>%mutate(density.values = upperRandomDensity)%>%select(distance.breaks.short, density.values, strand.plus.direction)%>%mutate(group = "upperRandomDensity")%>%mutate(group.main = "random")
    lowerRandomDensityValues <- randomDensity%>%mutate(density.values = lowerRandomDensity)%>%select(distance.breaks.short, density.values, strand.plus.direction)%>%mutate(group = "lowerRandomDensity")%>%mutate(group.main = "random")
    meanRandomDensityValues <- randomDensity%>%mutate(density.values = meanDensity)%>%select(distance.breaks.short, density.values, strand.plus.direction)%>%mutate(group = "meanDensity")%>%mutate(group.main = "random")        
## output #####   
    den <- rbind(targetDensity, upperRandomDensityValues, lowerRandomDensityValues, meanRandomDensityValues)
 return(den)
}

##takes the distribution table and reformats into prism format
prism_format_protospacer_distribution <- function(den){
## reformat for prism file #####
    dat <- den
    
    t5 <- dat%>%filter(strand.plus.direction == "t_5")%>%filter(group == "targets")%>%
      mutate(target.density.values = density.values)%>%
      select(distance.breaks.short, target.density.values)
    t3 <- dat%>%filter(strand.plus.direction == "t_3")%>%filter(group == "targets")%>%
      mutate(target.density.values = density.values)%>%
      select(distance.breaks.short, target.density.values)
    nt5 <- dat%>%filter(strand.plus.direction == "n_5")%>%filter(group == "targets")%>%
      mutate(non.target.density.values = density.values)%>%
      select(non.target.density.values)
    nt3 <- dat%>%filter(strand.plus.direction == "n_3")%>%filter(group == "targets")%>%
      mutate(non.target.density.values = density.values)%>%
      select( non.target.density.values)
    
    
    
    
    rmt5 <- dat%>%filter(strand.plus.direction == "t_5")%>%filter(group == "meanDensity")%>%
      mutate(random.mean.t.density.values = density.values)%>%
      select( random.mean.t.density.values)
    rmt3 <- dat%>%filter(strand.plus.direction == "t_3")%>%filter(group == "meanDensity")%>%
      mutate(random.mean.t.density.values = density.values)%>%
      select( random.mean.t.density.values)
    rmnt5 <- dat%>%filter(strand.plus.direction == "n_5")%>%filter(group == "meanDensity")%>%
      mutate(random.mean.n.density.values = density.values)%>%
      select( random.mean.n.density.values)
    rmnt3 <- dat%>%filter(strand.plus.direction == "n_3")%>%filter(group == "meanDensity")%>%
      mutate(random.mean.n.density.values = density.values)%>%
      select( random.mean.n.density.values)
    
    rlt5 <- dat%>%filter(strand.plus.direction == "t_5")%>%filter(group == "lowerRandomDensity")%>%
      mutate(random.lower.t.density.values = density.values)%>%
      select( random.lower.t.density.values)
    rlt3 <- dat%>%filter(strand.plus.direction == "t_3")%>%filter(group == "lowerRandomDensity")%>%
      mutate(random.lower.t.density.values = density.values)%>%
      select( random.lower.t.density.values)
    rlnt5 <- dat%>%filter(strand.plus.direction == "n_5")%>%filter(group == "lowerRandomDensity")%>%
      mutate(random.lower.n.density.values = density.values)%>%
      select( random.lower.n.density.values)
    rlnt3 <- dat%>%filter(strand.plus.direction == "n_3")%>%filter(group == "lowerRandomDensity")%>%
      mutate(random.lower.n.density.values = density.values)%>%
      select( random.lower.n.density.values)
    
    ruppt5 <- dat%>%filter(strand.plus.direction == "t_5")%>%filter(group == "upperRandomDensity")%>%
      mutate(random.upper.t.density.values = density.values)%>%
      select( random.upper.t.density.values)
    ruppt3 <- dat%>%filter(strand.plus.direction == "t_3")%>%filter(group == "upperRandomDensity")%>%
      mutate(random.upper.t.density.values = density.values)%>%
      select( random.upper.t.density.values)
    ruppnt5 <- dat%>%filter(strand.plus.direction == "n_5")%>%filter(group == "upperRandomDensity")%>%
      mutate(random.upper.n.density.values = density.values)%>%
      select( random.upper.n.density.values)
    ruppnt3 <- dat%>%filter(strand.plus.direction == "n_3")%>%filter(group == "upperRandomDensity")%>%
      mutate(random.upper.n.density.values = density.values)%>%
      select( random.upper.n.density.values)
    
    
    
    targets <- rbind(t5, t3)
    nontargets <- rbind(nt3, nt5)
    
    
    rmtargets <- rbind(rmt5, rmt3)
    rmnontargets <- rbind(rmnt3, rmnt5)
    
    
    rltargets <- rbind(rlt5, rlt3)
    rlnontargets <- rbind(rlnt3, rlnt5)
    
    rutargets <- rbind(ruppt5, ruppt3)
    runontargets <- rbind(ruppnt3, ruppnt5)
    
    hits <- cbind(targets, nontargets, 
                  rmtargets, rmnontargets,
                  rltargets, rlnontargets,
                  rutargets, runontargets)
return(hits)
}

##normalises the prism format data so that the maximum density is 1.
noramlise_distribution_values <- function(dat = hits){

dat <- dat%>%
  filter(!is.na(distance.breaks.short))%>%
  select(distance.breaks.short, target.density.values, non.target.density.values, random.mean.t.density.values, random.mean.n.density.values)


max <- max(c(max(dat$target.density.values), max(dat$non.target.density.values)))


dat <- dat%>%
  mutate(target.density.values = target.density.values/max)%>%
  mutate(non.target.density.values = -non.target.density.values/max)%>%
  mutate(random.mean.t.density.values = random.mean.t.density.values/max)%>%
  mutate(random.mean.n.density.values = -random.mean.n.density.values/max)

tmp <- dat%>%select(non.target.density.values)%>%mutate(line.number = c(nrow(dat):1))

dat <- dat%>%select(-non.target.density.values)%>%mutate(line.number = c(1:nrow(dat)))
dat <- left_join(dat, tmp, by = "line.number")

dat <- dat%>%select(distance.breaks.short, target.density.values, non.target.density.values, random.mean.t.density.values, random.mean.n.density.values)


row.null.neg <- c(-10000, 0,0,0,0)
row.null.pos <- c(10000, 0,0,0,0)

dat <- rbind(row.null.neg, dat, row.null.pos)

return(dat)
}

##gives a p-value and clustering % for a subtype
cluster_analysis <- function(swipeData = swipeData, Subtype.label = "I-F"){
subtypeData = swipeData%>%filter(Subtype == Subtype.label)
loop.length = 1000
    

set.seed(100)  

  targets.dat.replicated <- subtypeData[rep(seq_len(nrow(subtypeData)), loop.length), ]
  #targets.dat.replicated%>%targets.dat.replicated%>%filter(spacer.order_num > 1)
  rh <- targets.dat.replicated%>%
    mutate(distance.to.protospacer = runif(min = -0.5, max = 0.5, n = nrow(targets.dat.replicated)))%>%
    mutate(distance.to.protospacer = round(distance.to.protospacer*genome.length, 0))%>%
    mutate(distance.to.protospacer = ifelse(spacer.order.number == 1, 0, distance.to.protospacer))%>%
    mutate(target.strand = round(runif(min = 0, max = 1, n = nrow(targets.dat.replicated)), 0))%>%
    mutate(target.strand = ifelse(target.strand == 1, "t", "n"))%>%
    mutate(five.three.prime.dir = ifelse(distance.to.protospacer < 0, ifelse(target.strand == "t", 5, 3), ifelse(target.strand == "t", 3, 5)))%>%
    mutate(strand.plus.direction = paste(target.strand, five.three.prime.dir, sep = "_"))%>%
    mutate(target.pos = runif(min = 0, max = 1, n = nrow(targets.dat.replicated)))%>%
    mutate(target.pos = round(target.pos*genome.length, 0))
  rm(targets.dat.replicated)


  rh <- rh%>%group_by(host.target.pair, array.id, spacer.id, spacer.order.number)%>%mutate(replicate = row_number())%>%filter(spacer.order.number > 1)
  
dat <- subtypeData%>%filter(spacer.order.number > 1)
  
  
  mean.distance<- rh%>%group_by(replicate)%>%summarise(mean.value = mean(abs(distance.to.protospacer)))
  sd.distance<- rh%>%group_by(replicate)%>%summarise(sd.value = sd(distance.to.protospacer))
  
  distanceSummaryRH <- left_join(mean.distance, sd.distance, by = "replicate")
  
  
  mean.mean <- mean(distanceSummaryRH$mean.value)
  sd.mean <- sd(distanceSummaryRH$mean.value)
  
  mean.sd <- mean(distanceSummaryRH$sd.value)
  sd.sd <- sd(distanceSummaryRH$sd.value)

  
  
  n = length(dat$distance.to.protospacer) 
  s = sd(dat$distance.to.protospacer)        # sample standard deviation 
  SE = s/sqrt(n)
  E = qt(.975, df=n-1)*SE  
  
  xbar = mean(abs(dat$distance.to.protospacer))   # sample mean 
 ciData <- xbar + c(-E, E)
  
  n = length(rh$distance.to.protospacer) 
  s = sd(rh$distance.to.protospacer)        # sample standard deviation 
  SE = s/sqrt(n)
  E = qt(.975, df=n-1)*SE  
  
  xbar = mean(abs(rh$distance.to.protospacer))   # sample mean 
  ciRandom <- xbar + c(-E, E)
  

  return(paste(Subtype.label, pnorm(ciData[2], mean=mean.sd, sd=sd.sd, lower.tail=T), (mean(abs(rh$distance.to.protospacer)) - mean(abs(dat$distance.to.protospacer)))/mean(abs(rh$distance.to.protospacer))*100 ))
  
  
  
}

##gives a p-value for the ks-test results
ks_test_analysis <- function(swipeData, rh, Subtype.label = "I-F"){
  
sr <- rh%>%filter(Subtype == Subtype.label)%>%filter(spacer.order.number > 1)

##label the data as random and include the group number
sr <- sr%>%mutate(data.type = paste("random", group.number, sep = "_"))%>%
  mutate(data.type = ifelse(data.type == "random_1", "random_01", data.type))

##select the data that will be needed for determining posisiton
sr <- sr%>%select(distance.to.protospacer, data.type, strand.plus.direction)
    


st <- swipeData%>%filter(Subtype == Subtype.label)%>%filter(spacer.order.number > 1)


##label the data as target
st <- st%>%mutate(data.type = "targets")%>%
      mutate(strand = ifelse(strand.plus.direction == "n_5", "n", ifelse(strand.plus.direction == "n_3", "n", "t")))%>%
      select(-strand)

##select the data that will be needed for determining posisiton
st <- st%>%select(distance.to.protospacer, data.type, strand.plus.direction)

ks.res <- suppressWarnings(ks.test(sr$distance.to.protospacer, st$distance.to.protospacer))
return(ks.res)
}


```

```{r fix_array_direction, eval=FALSE, include=TRUE}
swipeData <-  read.table("refseq_83_swipe_setup.txt", comment.char = "", fill = T, sep = "\t", header = T, quote = "", as.is = T)
dat <-  read.table("two_or_more_hits_repeat_file_to_work_with.txt", comment.char = "", fill = T, sep = "\t", header = T, quote = "", as.is = T)
repeats <-  read.csv("New_Lookup_SJ-27-03-18-v4.csv", comment.char = "", fill = T, header = T, quote = "", as.is = T)



swipeData <- unique(swipeData)

swipeData <- swipeData%>%
  group_by(host.target.pair, array.id, spacer.number)%>%arrange(-bit.score.num)%>%
  mutate(duplicate.spacer.order = row_number())%>%
  ungroup()%>%
  group_by(host.target.pair, array.id, spacer.number, bit.score.num)%>%
  mutate(duplicate.spacers = n())


swipeData <- swipeData%>%filter(duplicate.spacer.order == 1 && duplicate.spacers == 1)%>%
  select(-duplicate.spacer.order, -duplicate.spacers)
tmp <- swipeData%>%group_by(host.target.pair)%>%filter()%>%mutate(hits.count = n())


##Keep the pairs with more than one match
swipeData <- swipeData%>%group_by(host.target.pair)%>%mutate(hits.count = n())%>%filter(hits.count > 1)







repeatData <- repeats%>%
  mutate(Primary_Repeat = Repeat)%>%
  select(-Repeat, -row)

dat <- left_join(dat, repeatData, by = "Primary_Repeat")




repeatsFound <- dat%>%filter(!is.na(as.character(Direction)))%>%
  mutate(subtype.correct = ifelse(subtype.list == Subtype, 1, ifelse(subtype.list == "II-A" & Subtype == "II", 1,ifelse(subtype.list == "II-C" & Subtype == "II", 1, 0) )))
repeatsOther <- dat%>%filter(is.na(as.character(Direction)))%>%
  mutate(subtype.correct = -1)


numberofSubtypes <- repeatsFound%>%select(assembly_accession, Subtype)%>%distinct()%>%group_by(assembly_accession)%>%summarise(subtype.count = n())


repeatsFound <- left_join(repeatsFound, numberofSubtypes, by = "assembly_accession")

repeatsFound <- repeatsFound%>%filter(subtype.count == 1)%>%select(-subtype.count)



##THIS IS CHANGING THE SUBTYPE TO MATCH THE CALL FROM THE REPEATS
typeI <- repeatsFound%>%filter(grepl("II", subtype.list) == F & grepl("II", Subtype) == F)%>%
  mutate(subtype.list = Subtype)
typeOther <- repeatsFound%>%filter(grepl("II", subtype.list) == T | grepl("II", Subtype) == T)%>%
  filter(subtype.correct == 1)

repeatsFound <- typeI%>%bind_rows(typeOther)

##THIS REMOVES INCORRECT SUBTYPE CALLS
# repeatsFound <- repeatsFound%>%filter(subtype.correct == 1)



repeatsFound <- repeatsFound%>%
  mutate(array.id = paste(contig, array.num, sep = "-"))

cRepeat <- repeatsFound%>%filter(Direction != "ReverseComplement")
rRepeat <- repeatsFound%>%filter(Direction == "ReverseComplement")

rRepeat <- rRepeat%>%group_by(array.id)%>%mutate(spacer.num.corrected= rev(spacer.num))
cRepeat <- cRepeat%>%mutate(spacer.num.corrected= spacer.num)

allRepeats <- rRepeat%>%bind_rows(cRepeat)

allRepeats <- allRepeats%>%mutate(spacer.id = paste(array.id, spacer.num, sep = "-"))%>%ungroup()%>%select(spacer.id, Direction, spacer.num.corrected, Subtype)

##FIX THIS
repeatsOther <- repeatsOther%>%mutate(Subtype = subtype.list)%>%mutate(Direction = rep("Not Found", nrow(repeatsOther)))%>%mutate(spacer.num.corrected = spacer.num)%>%mutate(spacer.id = paste(contig, array.num, spacer.num, sep = "-"))%>%ungroup()%>%select(spacer.id, Direction, spacer.num.corrected, Subtype)



 allRepeats <- allRepeats%>%bind_rows(repeatsOther)




swipeDataFixed <- swipeData%>%mutate(spacer.id = paste(array.id, spacer.number, sep = "-"))


swipeDataFixed <- left_join(swipeDataFixed, allRepeats, by = "spacer.id")
swipeDataFixed <- unique(swipeDataFixed)


table(swipeDataFixed$subtype.list)
table(swipeData$subtype.list)

##change the spacers and strands to the corrected versions
swipeDataFixed <- swipeDataFixed%>%mutate(Direction = ifelse(is.na(Direction), "Keep anyway", Direction))%>%filter(Direction != "Not Found")%>%
  mutate(spacer.number = spacer.num.corrected)%>%
  mutate(strand = ifelse(Direction == "ReverseComplement", -1*strand, strand))

table(swipeDataFixed$subtype.list)


swipeData <- swipeDataFixed%>%select(-spacer.id, -Direction, -spacer.num.corrected)
swipeData <- swipeData%>%mutate(Subtype = ifelse(is.na(Subtype), subtype.list, Subtype))%>%
  mutate(subtype.list = ifelse(Subtype == "II", subtype.list, Subtype))%>%
  filter(subtype.list == "I-B" |subtype.list == "I-C" |subtype.list == "I-E" |subtype.list == "I-F" |subtype.list == "II-A" |subtype.list == "II-C")%>%select(-Subtype)


table(swipeData$subtype.list)


##
write.table(swipeData, "refseq_83_swipe_array_direction_corrected.txt", sep = "\t", quote = F, row.names = F, col.names = T)


```

```{r host_target_pair_setup, eval = F, include=T}
swipeData <-  read.table("refseq_83_swipe_array_direction_corrected.txt", comment.char = "", fill = T, sep = "\t", header = T, quote = "")

##remove duplicate spacers. Keep the match with the highest bit score. Remove the matches where a spacer matches multiple sites with the same score (too difficult to confidently resolve which match is the "correct" match).

swipeData <- unique(swipeData)

##Assign the spacer order for which match is the oldest to newest
swipeData <- swipeData%>%group_by(host.target.pair)%>%arrange(-as.numeric(spacer.number))%>%mutate(spacer.order.number = row_number())



##get the PPS data so that columns containing position and strand can be used to work out strand and direction for the subsequent matches
ppsData <- swipeData%>%
  filter(spacer.order.number == 1)%>%
  mutate(pps.strand = strand)%>%
  mutate(pps.target.pos = target.pos)%>%
select(host.target.pair, pps.strand, pps.target.pos)

swipeData <- left_join(swipeData, ppsData, by = "host.target.pair")

##assign the strand based on whether each of the matches are on the same strand as the PPS. Calculate the distance from the PPS to each of these hits.
swipeData <- swipeData%>%
  mutate(target.strand = ifelse(strand == pps.strand, "t", "n"))%>%
  mutate(distance.to.protospacer = pps.target.pos - target.pos)


##identify protospacers that are closer when the genome is treated as linear
swipeData <- swipeData%>%mutate(shorter.distance.exists = ifelse(abs(as.numeric(distance.to.protospacer)) < as.numeric(genome.length)/2, "y","n"))

##Get genome distances from circular genomes
lengeths.greater.than.half <- swipeData%>%
  filter(shorter.distance.exists == "n")%>%
  mutate(distance.to.protospacer = ifelse(distance.to.protospacer < 0 ,
                                           as.numeric(distance.to.protospacer) + as.numeric(genome.length),
                                           as.numeric(distance.to.protospacer) - as.numeric(genome.length)))
lengeths.less.than.half <- swipeData%>%filter(shorter.distance.exists == "y")%>%mutate(distance.to.protospacer = distance.to.protospacer)

##combine the two sets of genomes
swipeData <- rbind(lengeths.less.than.half, lengeths.greater.than.half)
swipeData <- swipeData%>%select(-pps.target.pos, -shorter.distance.exists)

##select the data that is not the PPS 
not.PPS.dat <- swipeData%>%filter(spacer.order.number != 1)

##select the PPS data
first.spacer.dat <- swipeData%>%filter(spacer.order.number == 1)

##calculate 5' and 3' direction
not.PPS.dat <- not.PPS.dat%>%mutate(five.three.prime.dir = ifelse(pps.strand == 1, 
                                                                  ifelse(target.strand == "t", 
                                                                         ifelse(distance.to.protospacer < 0 , "5", "3"), 
                                                                         ifelse(distance.to.protospacer < 0 , "3", "5")), 
                                                                  ifelse(target.strand == "t", 
                                                                         ifelse(distance.to.protospacer < 0 , "3", "5"), 
                                                                         ifelse(distance.to.protospacer < 0 , "5", "3"))))

first.spacer.dat <- first.spacer.dat%>%mutate(five.three.prime.dir = "0")

##combine the data
swipeData <- rbind(first.spacer.dat, not.PPS.dat)

write.table(swipeData, "refseq_83_swipe_host.target.pair.setup.txt", sep = "\t", quote = F, row.names = F, col.names = T)

rm(lengeths.greater.than.half)
rm(lengeths.less.than.half)
rm(ppsData)

```

```{r PPS_scores, eval = F, include=T}
swipeData <-  read.table("refseq_83_swipe_host.target.pair.setup.txt", comment.char = "", fill = T, sep = "\t", header = T)


##get the number of arrays involved in each host-target pair
number.of.arrays <- swipeData%>%group_by(host.target.pair)%>%summarise(num.of.arrays= length(unique(array.id)))

##add a column containing the number of arrays in each host.target.pair
swipeData <- left_join(swipeData, number.of.arrays, by = "host.target.pair")

##score the PPS 5 if the host target pair only has one array.
swipeData <- mutate(swipeData, PPS.score.num = ifelse(num.of.arrays==1, 5, NA))

##add a column that labels each of the hits based on the age of the spacer (oldest to youngest based on how far along the array that they are found)
swipeData <- swipeData%>%group_by(host.target.pair)%>%arrange(-spacer.number)%>%mutate(spacer.order.number = row_number())

##obtain the two oldest spacers and check if these are from the same array
number.of.arrays.first.two.spacers <- swipeData%>%
  group_by(host.target.pair)%>%
  top_n(n = 2, wt = -spacer.order.number)%>%
  summarise(number.of.arrays.first.two.spacers.num = length(unique(array.id)))

##add the column with the information about whether the two oldest spacers are from the same array
swipeData <- left_join(swipeData, number.of.arrays.first.two.spacers, by = "host.target.pair")

##if the two oldest spacers are from the same array then score the PPS 4
swipeData <- mutate(swipeData, PPS.score.num = ifelse(number.of.arrays.first.two.spacers.num==1 && num.of.arrays > 1, 4, PPS.score.num))
swipeData <- as.data.frame(swipeData)

##get the data for the oldest spacers in a new data frame
first.spacer.dat <- swipeData%>%
  group_by(host.target.pair)%>%
  filter(number.of.arrays.first.two.spacers.num == 2)%>%
  filter(spacer.order.number == 1)

##get the data for the second oldest spacers in a new data frame
second.spacer.dat <- swipeData%>%
  group_by(host.target.pair)%>%
  filter(number.of.arrays.first.two.spacers.num == 2)%>%
  filter(spacer.order.number == 2)%>%
  ungroup()%>%
  select(spacer.number, host.target.pair)

colnames(second.spacer.dat) <- c("spacer.num.2", "host.target.pair")

##combine the data for the first and second spacers so that each of the host.target pairs has a single row with the spacer number of each
first.and.second.spacer.dat <- left_join(first.spacer.dat, second.spacer.dat, by = "host.target.pair")

##add a column where the the percentage difference of the two spacer numbers is recorded
first.and.second.spacer.dat <- mutate(first.and.second.spacer.dat, spacer.diff.num = spacer.num.2/spacer.number)

##if the percentage difference is  then score the PPS 3 and keep the hits with a PPS score 3 or greater
first.and.second.spacer.dat <-  mutate(first.and.second.spacer.dat, PPS.score.num = ifelse(number.of.arrays.first.two.spacers.num==2 && spacer.diff.num < 0.65, 3, 0))%>%filter(PPS.score.num != 0)%>%select(-spacer.diff.num, -spacer.num.2)

##remove the rows from the main data that are contain in the first.and.second.spacer.dat (to be re added with the PPS score data)
swipeData.pps.4.5 <- swipeData%>%filter(!is.na(PPS.score.num))
swipeData.pps.4.5 <- as.data.frame(swipeData.pps.4.5)

swipeData.pps.3 <- swipeData%>%filter(is.na(PPS.score.num))
swipeData.pps.3 <- as.data.frame(swipeData.pps.3)

first.and.second.spacer.dat <- as.data.frame(first.and.second.spacer.dat)
first.and.second.spacer.dat <- first.and.second.spacer.dat%>%mutate(x = PPS.score.num)%>%select(host.target.pair, x)
swipeData.pps.3 <- left_join(swipeData.pps.3, first.and.second.spacer.dat, by = "host.target.pair")
swipeData.pps.3 <- swipeData.pps.3%>%mutate(PPS.score.num = x)%>%select(-x)

##combine the data with a PPS score of 4 and 5 with the data frame with PPS score of 3 (this is now the complete data set again)
swipeData  <- rbind(swipeData.pps.4.5, swipeData.pps.3)

table(swipeData$PPS.score.num)

##check one more time that all the rows are unique and contain data that is wanted
swipeData <- swipeData%>%filter(!is.na(PPS.score.num))%>%distinct()


swipeData <- swipeData%>%select(-number.of.arrays.first.two.spacers.num, -PPS.score.num, -num.of.arrays)
swipeData <- swipeData%>%filter(!is.na(distance.to.protospacer))

write.table(swipeData, "refseq_83_swipe_PPS.scores.txt", sep = "\t", quote = F, row.names = F, col.names = T)


rm(first.and.second.spacer.dat)
rm(first.spacer.dat)
rm(number.of.arrays)
rm(number.of.arrays.first.two.spacers)
rm(second.spacer.dat)
rm(swipeData.pps.3)
rm(swipeData.pps.4.5)


```

```{r remove_redundancy, eval = F, include=T}

swipeData <-  read.table("refseq_83_swipe_PPS.scores.txt", comment.char = "", fill = T, sep = "\t", header = T)

swipeData <- swipeData%>%mutate(keep.bit = ifelse(spacer.order.number > 1, ifelse(bit.score.num < 23, F, T),T))%>%
  filter(keep.bit == T)%>%
  select(-keep.bit)







swipeData <- swipeData%>%group_by(host.target.pair)%>%mutate(hits.count = n())%>%filter(hits.count > 1)


##Assign the spacer order for which match is the oldest to newest
swipeData <- swipeData%>%group_by(host.target.pair)%>%arrange(-as.numeric(spacer.number))%>%mutate(spacer.order.number = row_number())

swipeData <- swipeData%>%mutate(host.acc. = assembly_accession)



tmp <- swipeData%>%filter(spacer.order.number > 1)

###filtering for multiple spacers hitting the same target site

##create column containing the target position, accession1 and the spacer order number (should all of these be included?).
swipeData <- swipeData%>%mutate(unique.protospacer.host.match =  paste(target.acc., target.pos, target.strand, spacer.order.number, sep = "_"))


#bit.scores <- swipeData%>%group_by(unique.protospacer.host.match)%>%summarise(maax.bit.score = round(mean(bit.score.num)))

#swipeData <- left_join(swipeData, bit.scores, by = "unique.protospacer.host.match")

#swipeData <- swipeData%>%mutate(bit.score.num = maax.bit.score)%>%select(-maax.bit.score)

##combine each of the unique.protospacer.host.matches for each of the host target pairs so that the entire match is summarised in one column.
host.target.pair.summary <- swipeData%>%group_by(target.acc.,host.target.pair)%>%summarise(all.target.starts = paste(unlist(list(unique.protospacer.host.match)), collapse = ","))
host.target.pair.summary <- as.data.frame(host.target.pair.summary)

##count the number of times each of the host genomes are identical for each of the target genomes.
number.of.duplicate.host.genomes <- host.target.pair.summary%>%group_by(target.acc.,all.target.starts)%>%summarise(duplicate.genomes = n())%>%ungroup()%>%select(-target.acc.)

##add th number of times each of the host genomes occurs to the data set containing the host.target.pair data.
host.target.pair.summary <- left_join(host.target.pair.summary, number.of.duplicate.host.genomes, by = "all.target.starts")
host.target.pair.summary <- host.target.pair.summary%>%ungroup()%>%select(-target.acc.)

##add the duplicate genomes data to the hits data
swipeData <- left_join(swipeData, host.target.pair.summary, by = "host.target.pair")
swipeData <- unique(swipeData)

##select the hits that are part of duplicated host genomes.
duplicate.host.genomes <- swipeData%>%filter(duplicate.genomes != 1)
#duplicate.host.genomes[,2] <- as.character(duplicate.host.genomes$host.acc.)


dat <- duplicate.host.genomes
length(unique(dat$target.acc.))
length(unique(dat$host.acc.))
length(unique(dat$host.target.pair))


##create a combined 'genome' name containing each of the host genome names that are duplicated for a target genome.
merged.host.genome.names <- duplicate.host.genomes%>%group_by(all.target.starts)%>%summarise(matching.host.genomes = paste(unlist(list(unique(host.acc.))), collapse = "$merged_"))

##add the matching.host.genomes to the hits data based to label the duplicate genomes by which other genomes are identical.
duplicate.host.genomes <- left_join(duplicate.host.genomes, merged.host.genome.names, by = "all.target.starts")

##relabel the host genome column with the matching.host.genomes column and the the host.target.pair column
duplicate.host.genomes <- duplicate.host.genomes%>%
  ungroup()%>%
  mutate(host.acc. = matching.host.genomes)%>%
  mutate(host.target.pair = paste(host.acc., target.acc., sep = "$"))%>%
  mutate(array.id=paste(unlist(list(unique(array.id))), collapse = "$merged_"))%>%
  select(-matching.host.genomes, -spacer.acc., -assembly_accession, -unique.protospacer.host.match, -all.target.starts)

duplicate.host.genomes <- unique(duplicate.host.genomes)






dat <- duplicate.host.genomes
length(unique(dat$target.acc.))
length(unique(dat$host.acc.))
length(unique(dat$host.target.pair))


##select the hits that where there is no duplicate host genome for a target genome. Further analysis will be done to check these are not similar enough to be called duplcaites.
one.host.genome <- swipeData%>%filter(duplicate.genomes == 1)
one.host.genome <- unique(one.host.genome)


########

one.host.genome <- one.host.genome%>%
  select( -spacer.acc., -assembly_accession, -unique.protospacer.host.match, -all.target.starts)

##combine the now filtered duplicate.host.genomes with the one.host.genome
one.host.genome <- rbind(as.data.frame(one.host.genome), as.data.frame(duplicate.host.genomes))


##add unique hit information to a column 
one.host.genome <- one.host.genome%>%mutate(unique.protospacer.host.match =  paste(target.acc., target.pos, sep = "_"))



dat <- one.host.genome
length(unique(dat$target.acc.))
length(unique(dat$host.acc.))
length(unique(dat$host.target.pair))



##count the number of times a protospacer site is matched
protospacer.counts.dat <- one.host.genome%>%group_by(target.acc., unique.protospacer.host.match)%>%summarise(protospacer.freq.num = n())%>%ungroup()%>%select(-target.acc.)


##add the protospacer counts data
one.host.genome <- left_join(one.host.genome, protospacer.counts.dat, by = "unique.protospacer.host.match")
one.host.genome <- unique(one.host.genome)

##count the number of spacers that are duplicated in each host-target pair (e.g. if there are 7 matches, how many of the 7 have more than one host genome targeting each site)
spacer.counts.dat <- one.host.genome%>%filter(protospacer.freq.num > 1)%>%group_by(host.target.pair)%>%summarise(shared.protospacer.num = n())

##add the spacer counts data
one.host.genome <- left_join(one.host.genome, spacer.counts.dat, by ="host.target.pair")

##keep the host-target pairs with no duplicate spacers
no.duplicate.spacer <- one.host.genome%>%filter(is.na(shared.protospacer.num))

dat <- no.duplicate.spacer
length(unique(dat$target.acc.))
length(unique(dat$Genome))
length(unique(dat$host.target.pair))

i.e <- dat%>%filter(Subtype == "I-E")

length(unique(i.e$target.acc.))
length(unique(i.e$Genome))
length(unique(i.e$host.target.pair))

##keep the host-target pairs with only a single shared protospacer site (this should look at only the cases where the PPS is duplicated initially)
single.duplicate.spacer <- one.host.genome%>%filter(shared.protospacer.num == 1)


dat <- single.duplicate.spacer
length(unique(dat$target.acc.))
length(unique(dat$Genome))
length(unique(dat$host.target.pair))

i.e <- dat%>%filter(Subtype == "I-E")
length(unique(i.e$target.acc.))
length(unique(i.e$Genome))
length(unique(i.e$host.target.pair))

##is the PPS the duplicated spacer?
PPS.duplicate.spacer <- single.duplicate.spacer%>%filter(spacer.order.number == 1)%>%mutate(pps.spacer.duplicated = ifelse(protospacer.freq.num > 1, T, F))%>%select(host.target.pair, pps.spacer.duplicated)
single.duplicate.spacer <- left_join(single.duplicate.spacer, PPS.duplicate.spacer, by = "host.target.pair")

##select the spacers that are only duplicated at the PPS
PPS.duplicate.spacer <- single.duplicate.spacer%>%filter(pps.spacer.duplicated == T)

dat <- PPS.duplicate.spacer
length(unique(dat$target.acc.))
length(unique(dat$Genome))
length(unique(dat$host.target.pair))

i.e <- dat%>%filter(Subtype == "I-E")
length(unique(i.e$target.acc.))
length(unique(i.e$Genome))
length(unique(i.e$host.target.pair))




##select the remaining spacers
other.spacers <- one.host.genome%>%filter(shared.protospacer.num > 1)


PPS.duplicate.spacer <- PPS.duplicate.spacer%>%select(-pps.spacer.duplicated)
swipeData <- rbind(no.duplicate.spacer, PPS.duplicate.spacer)
###
write.table(swipeData, "refseq_83.swipe.hosts_nr_15-2-18.txt", sep = "\t", quote = F, row.names = F, col.names = T)


rm(duplicate.host.genomes)
rm(host.target.pair.summary)
rm(merged.host.genome.names)
rm(no.duplicate.spacer)
rm(number.of.duplicate.host.genomes)
rm(one.host.genome)
rm(other.spacers)
rm(PPS.duplicate.spacer)
rm(protospacer.counts.dat)
rm(single.duplicate.spacer)
rm(spacer.counts.dat)


# swipeData <-  read.table("~/../../Volumes/2TTJN/Project_Large_Files/CRISPR_Clustering/refseq_83.swipe.hosts_nr", comment.char = "", fill = T, sep = "\t", header = T)
# swipeData <-  read.table("refseq_83.swipe.hosts_nr", comment.char = "", fill = T, sep = "\t", header = T)


##create column containing the target position, the bit score of the match and the spacer order number (should all of these be included?).
swipeData <- swipeData%>%mutate(spacer.id =  paste(spacer.number, array.id, spacer.order.number, host.acc., sep = "_"))





#bit.scores <- swipeData%>%group_by(spacer.id)%>%summarise(maax.bit.score = round(mean(bit.score.num)))

#swipeData <- left_join(swipeData, bit.scores, by = "spacer.id")

#swipeData <- swipeData%>%mutate(bit.score.num = maax.bit.score)%>%select(-maax.bit.score)


# hist(swipeData$bit.score.num, breaks = 20)


# tmp <- swipeData%>%filter(spacer.order.number > 1)
# hist(tmp$bit.score.num, breaks = 20)

##combine each of the spacer.ides for each of the host target pairs so that the entire match is summarised in one column.
host.target.pair.summary <- swipeData%>%
  group_by(host.acc.,host.target.pair)%>%
  summarise(all.host.starts = paste(unlist(list(spacer.id)), collapse = ","))

host.target.pair.summary <- as.data.frame(host.target.pair.summary)



##count the number of times each of the host genomes are identical for each of the target genomes.
number.of.duplicate.target.genomes <- host.target.pair.summary%>%
  group_by(host.acc.,all.host.starts)%>%
  summarise(duplicate.targets = n())%>%
  ungroup()%>%select(-host.acc.)

##add th number of times each of the host genomes occurs to the data set containing the host.target.pair data.
host.target.pair.summary <- left_join(host.target.pair.summary, number.of.duplicate.target.genomes, by = "all.host.starts")
host.target.pair.summary <- host.target.pair.summary%>%ungroup()%>%select(-host.acc.)

##add the duplicate genomes data to the hits data
swipeData <- left_join(swipeData, host.target.pair.summary, by = "host.target.pair")
swipeData <- unique(swipeData)




####

##select the duplicated genomes
duplicate.target.genomes <- swipeData%>%filter(duplicate.targets > 1)



###check that there are still >= 2 hits per pair (there aren't for a few of them?)
tmp <- duplicate.target.genomes%>%select(host.target.pair, spacer.id)%>%distinct()%>%group_by(host.target.pair)%>%summarise(x = n())


##create a combined 'genome' name containing each of the host genome names that are duplicated for a target genome.
merged.target.genome.names <- duplicate.target.genomes%>%
  group_by(all.host.starts)%>%
  summarise(matching.target.genomes = paste(unlist(list(unique(target.acc.))), collapse = "$merged_"))

##add the matching.host.genomes to the hits data based to label the duplicate genomes by which other genomes are identical.
duplicate.target.genomes <- left_join(duplicate.target.genomes, merged.target.genome.names, by = "all.host.starts")



tt <- duplicate.target.genomes%>%ungroup()%>%
  mutate(target.acc. = matching.target.genomes)%>%
  mutate(host.target.pair = paste(host.acc., target.acc., sep = "__"))%>%
  mutate(prop.distance.to.protospacer = distance.to.protospacer/genome.length)%>%
  group_by(host.target.pair, spacer.id)%>%
  summarise(mean.protospacer.distance.prop = mean(prop.distance.to.protospacer))%>%
  mutate(merged.spacer.id = paste(host.target.pair, spacer.id, sep = "_"))%>%ungroup()%>%
  select(-host.target.pair, -spacer.id)



duplicate.target.genomes <- duplicate.target.genomes%>%
  mutate(target.acc. = matching.target.genomes)%>%
  mutate(host.target.pair = paste(host.acc., target.acc., sep = "__"))%>%
  mutate(merged.spacer.id = paste(host.target.pair, spacer.id, sep = "_"))


duplicate.target.genomes <- left_join(duplicate.target.genomes, tt, by = "merged.spacer.id")


###check that each of the spacers has only one distance.
tmp <- duplicate.target.genomes%>%select(merged.spacer.id, mean.protospacer.distance.prop)%>%distinct()%>%group_by(merged.spacer.id)%>%summarise(x = n())


duplicate.target.genomes <- duplicate.target.genomes%>%
  mutate(protospacer.distance.num.2 = mean.protospacer.distance.prop)%>%
  mutate(distance.is.averaged = ifelse(protospacer.distance.num.2 == mean.protospacer.distance.prop, T, F))

table(duplicate.target.genomes$distance.is.averaged)

#tt <- duplicate.target.genomes%>%group_by(matching.target.names)%>%


tt <- duplicate.target.genomes%>%
  group_by(merged.spacer.id)%>%
  summarise(mean.genome.length = mean(genome.length))

duplicate.target.genomes <- left_join(duplicate.target.genomes, tt, by = "merged.spacer.id")


tt <- duplicate.target.genomes%>%
  group_by(merged.spacer.id)%>%
  summarise(mean.target.pos = mean(target.pos))



duplicate.target.genomes <- left_join(duplicate.target.genomes, tt, by = "merged.spacer.id")

duplicate.target.genomes <- duplicate.target.genomes%>%ungroup()%>%
  mutate(target.acc. = matching.target.genomes)%>%
  mutate(genome.length = mean.genome.length)%>%
  mutate(target.pos = mean.target.pos)%>%
  mutate(host.target.pair = paste(host.acc., target.acc., sep = "__"))%>%
  mutate(distance.to.protospacer = round(protospacer.distance.num.2*genome.length))%>%
select(-unique.protospacer.host.match, -protospacer.freq.num, -shared.protospacer.num)
  

hits.counter <- duplicate.target.genomes%>%select(host.target.pair, merged.spacer.id)%>%distinct()%>%group_by(host.target.pair)%>%summarise(hits.count = n())

spacer.order <- duplicate.target.genomes%>%select(host.target.pair, merged.spacer.id, spacer.number)%>%distinct()%>%group_by(host.target.pair)%>%arrange(-spacer.number)%>%mutate(spacer.order.number = row_number())%>%ungroup()%>%select(merged.spacer.id, spacer.order.number)


duplicate.target.genomes <- duplicate.target.genomes%>%select(-spacer.order.number, -hits.count)

duplicate.target.genomes <- left_join(duplicate.target.genomes, hits.counter, by = "host.target.pair")
duplicate.target.genomes <- left_join(duplicate.target.genomes, spacer.order, by = "merged.spacer.id")

duplicate.target.genomes <- unique(duplicate.target.genomes)

duplicate.target.genomes <- duplicate.target.genomes%>%mutate(x = runif(nrow(duplicate.target.genomes), 0, 1))

duplicate.target.genomes <- duplicate.target.genomes%>%
  group_by(merged.spacer.id)%>%
  arrange(x)%>%
  mutate(y = row_number())%>%
  filter(y == 1)%>%
  select(-x, -y)

duplicate.target.genomes <- duplicate.target.genomes%>%
  filter(distance.is.averaged == T)%>%
  group_by(merged.spacer.id)%>%
  mutate(duplicate.count = n())





##select the target genomes that are unique
one.target.genome <- swipeData%>%filter(duplicate.targets == 1)


one.target.genome <- one.target.genome%>%select(host.target.pair, subtype.list, target.acc.,     
  host.acc.,  array.id, spacer.number,   
  target.pos, strand,  genome.length,   
 pps.strand, target.strand, distance.to.protospacer,       
 duplicate.genomes, spacer.id, all.host.starts, 
 duplicate.targets,  hits.count,      
 spacer.order.number, bit.score.num)

duplicate.target.genomes <- duplicate.target.genomes%>%ungroup()%>%select(host.target.pair, subtype.list, target.acc.,     
  host.acc.,  array.id, spacer.number,   
  target.pos, strand,  genome.length,   
 pps.strand, target.strand, distance.to.protospacer,       
 duplicate.genomes, spacer.id, all.host.starts, 
 duplicate.targets,  hits.count,      
 spacer.order.number, bit.score.num)

one.target.genome <- rbind(one.target.genome, duplicate.target.genomes)

##count the number of times a spacer matches protospacer sites
spacer.counts.dat <- one.target.genome%>%group_by(host.acc., spacer.id)%>%summarise(spacer.freq.num = n())%>%ungroup()%>%select(-host.acc.)

##add the protospacer counts data
one.target.genome <- left_join(one.target.genome, spacer.counts.dat, by = "spacer.id")
one.target.genome <- unique(one.target.genome)

##count the number of spacers that are duplicated in each host-target pair
spacer.counts.dat <- one.target.genome%>%filter(spacer.freq.num > 1)%>%group_by(host.target.pair)%>%summarise(shared.spacer.num = n())

##add the spacer counts data
one.target.genome <- left_join(one.target.genome, spacer.counts.dat, by ="host.target.pair")

##keep the host-target pairs with no duplicate spacers
no.duplicate.spacer <- one.target.genome%>%filter(is.na(shared.spacer.num))



##keep the host-target pairs with only a single shared protospacer site (this should look at only the cases where the PPS is duplicated initially)
single.duplicate.protospacer <- one.target.genome%>%filter(shared.spacer.num == 1)

##is the PPS the duplicated protospacer?
PPS.duplicate.protospacer <- single.duplicate.protospacer%>%filter(spacer.order.number == 1)%>%mutate(pps.protospacer.duplicated = ifelse(spacer.freq.num > 1, T, F))%>%select(host.target.pair, pps.protospacer.duplicated)
single.duplicate.protospacer <- left_join(single.duplicate.protospacer, PPS.duplicate.protospacer, by = "host.target.pair")

##select the spacers that are only duplicated at the PPS
PPS.duplicate.protospacer <- single.duplicate.protospacer%>%filter(pps.protospacer.duplicated == T)


write.table(PPS.duplicate.protospacer, "refseq_79.swipe.one_duplicate_pps_target", sep = "\t", quote = F, row.names = F, col.names = T)

PPS.duplicate.protospacer <- PPS.duplicate.protospacer%>%select(-pps.protospacer.duplicated)


swipeData <- rbind(no.duplicate.spacer, PPS.duplicate.protospacer)


  
  
  
  ##select the data that is not the PPS 
not.PPS.dat <- swipeData%>%filter(spacer.order.number != 1)

##select the PPS data
first.spacer.dat <- swipeData%>%filter(spacer.order.number == 1)

##calculate 5' and 3' direction
not.PPS.dat <- not.PPS.dat%>%mutate(five.three.prime.dir = ifelse(pps.strand == 1, 
                                                                  ifelse(target.strand == "t", 
                                                                         ifelse(distance.to.protospacer < 0 , "5", "3"), 
                                                                         ifelse(distance.to.protospacer < 0 , "3", "5")), 
                                                                  ifelse(target.strand == "t", 
                                                                         ifelse(distance.to.protospacer < 0 , "3", "5"), 
                                                                         ifelse(distance.to.protospacer < 0 , "5", "3"))))

first.spacer.dat <- first.spacer.dat%>%mutate(five.three.prime.dir = "0")

##combine the data
swipeData <- rbind(first.spacer.dat, not.PPS.dat)


swipeData <- swipeData%>%mutate(unique.spacer.target.match =  paste(spacer.number, array.id, spacer.order.number, host.acc., sep = "_"))%>%
  mutate(Subtype = subtype.list)%>%
  select(-subtype.list)

distances <- as.data.frame(table(swipeData$distance.to.protospacer))
colnames(distances) <- c("distance.to.protospacer", "frequency.of.distance")
distances <- distances%>%mutate(distance.to.protospacer = as.numeric(as.character(distance.to.protospacer)))


swipeData <- left_join(swipeData, distances, by = "distance.to.protospacer")

swipeData <- swipeData%>%
  mutate(keep.spacer = ifelse(spacer.order.number == 1, T, ifelse(frequency.of.distance < 4, T, F)))%>%
  filter(keep.spacer == T)%>%
  select(-keep.spacer)

swipeData <- swipeData%>%mutate(distance.to.protospacer = -distance.to.protospacer)%>%
  mutate(five.three.prime.dir = ifelse(pps.strand == 1, 
                                                                  ifelse(target.strand == "t", 
                                                                         ifelse(distance.to.protospacer < 0 , "5", "3"), 
                                                                         ifelse(distance.to.protospacer < 0 , "3", "5")), 
                                                                  ifelse(target.strand == "t", 
                                                                         ifelse(distance.to.protospacer < 0 , "3", "5"), 
                                                                         ifelse(distance.to.protospacer < 0 , "5", "3")))
                                )

#swipeData <- swipeData%>%
#  mutate(distance.to.protospacer = -distance.to.protospacer)%>%
#  mutate(five.three.prime.dir = ifelse(strand*distance.to.protospacer == 0, "0", ifelse(strand*distance.to.protospacer < 0, "3", "5")))




#swipeData <- swipeData%>%
#  mutate(five.three.prime.dir = ifelse(five.three.prime.dir == "3", "6", ifelse(five.three.prime.dir == "5", "2", #"0")))%>%
#  mutate(five.three.prime.dir = ifelse(five.three.prime.dir == "6", "5",  ifelse(five.three.prime.dir == "2", "3", #"0")))

swipeData <- swipeData%>%filter(hits.count < 6)

write.table(swipeData, "refseq_83.swipe.nr_27-3-18.txt", sep = "\t", quote = F, row.names = F, col.names = T)

write.table(swipeData, "Project/CRISPR_Analysis_Shiny_App/refseq_83.swipe.nr_27-3-18.txt", sep = "\t", quote = F, row.names = F, col.names = T)

write.table(swipeData, "Project/CRISPR_Analysis_Shiny_App_Fast/refseq_83.swipe.nr_27-3-18.txt", sep = "\t", quote = F, row.names = F, col.names = T)



rm(duplicate.target.genomes)
rm(host.target.pair.summary)
rm(merged.target.genome.names)
rm(no.duplicate.spacer)
rm(number.of.duplicate.target.genomes)
rm(one.target.genome)
rm(PPS.duplicate.protospacer)
rm(spacer.counts.dat)
rm(spacer.order)
rm(hits.counter)
rm(single.duplicate.protospacer)
rm(tmp)
rm(tt)






```

```{r clustered_genomes}

swipeData <-  read.table("refseq_83_swipe_PPS.scores.txt", comment.char = "", fill = T, sep = "\t", header = T)

#####
swipeData <- swipeData%>%mutate(keep.bit = ifelse(spacer.order.number > 1, ifelse(bit.score.num < 23, F, T),T))%>%
  filter(keep.bit == T)%>%
  select(-keep.bit)



##Filter to determine clustering
 swipeData <- swipeData%>%filter(hits.count > 2)%>%filter(hits.count < 6)

df <- swipeData%>%group_by(host.target.pair)%>%summarise(sdValues = mean(abs(distance.to.protospacer)))%>%
  mutate(clustered = ifelse(sdValues < 5000, T, F))%>%
  select(-sdValues)

swipeData <- left_join(swipeData, df, by = "host.target.pair")

swipeData <- swipeData%>%filter(clustered == T)



#####

swipeData <- swipeData%>%group_by(host.target.pair)%>%mutate(hits.count = n())%>%filter(hits.count > 1)


##Assign the spacer order for which match is the oldest to newest
swipeData <- swipeData%>%group_by(host.target.pair)%>%arrange(-as.numeric(spacer.number))%>%mutate(spacer.order.number = row_number())

swipeData <- swipeData%>%mutate(host.acc. = assembly_accession)



tmp <- swipeData%>%filter(spacer.order.number > 1)

###filtering for multiple spacers hitting the same target site

##create column containing the target position, accession1 and the spacer order number (should all of these be included?).
swipeData <- swipeData%>%mutate(unique.protospacer.host.match =  paste(target.acc., target.pos, target.strand, spacer.order.number, sep = "_"))



##combine each of the unique.protospacer.host.matches for each of the host target pairs so that the entire match is summarised in one column.
host.target.pair.summary <- swipeData%>%group_by(target.acc.,host.target.pair)%>%summarise(all.target.starts = paste(unlist(list(unique.protospacer.host.match)), collapse = ","))
host.target.pair.summary <- as.data.frame(host.target.pair.summary)

##count the number of times each of the host genomes are identical for each of the target genomes.
number.of.duplicate.host.genomes <- host.target.pair.summary%>%group_by(target.acc.,all.target.starts)%>%summarise(duplicate.genomes = n())%>%ungroup()%>%select(-target.acc.)

##add th number of times each of the host genomes occurs to the data set containing the host.target.pair data.
host.target.pair.summary <- left_join(host.target.pair.summary, number.of.duplicate.host.genomes, by = "all.target.starts")
host.target.pair.summary <- host.target.pair.summary%>%ungroup()%>%select(-target.acc.)

##add the duplicate genomes data to the hits data
swipeData <- left_join(swipeData, host.target.pair.summary, by = "host.target.pair")
swipeData <- unique(swipeData)

##select the hits that are part of duplicated host genomes.
duplicate.host.genomes <- swipeData%>%filter(duplicate.genomes != 1)
#duplicate.host.genomes[,2] <- as.character(duplicate.host.genomes$host.acc.)


dat <- duplicate.host.genomes
length(unique(dat$target.acc.))
length(unique(dat$host.acc.))
length(unique(dat$host.target.pair))


##create a combined 'genome' name containing each of the host genome names that are duplicated for a target genome.
merged.host.genome.names <- duplicate.host.genomes%>%group_by(all.target.starts)%>%summarise(matching.host.genomes = paste(unlist(list(unique(host.acc.))), collapse = "$merged_"))

##add the matching.host.genomes to the hits data based to label the duplicate genomes by which other genomes are identical.
duplicate.host.genomes <- left_join(duplicate.host.genomes, merged.host.genome.names, by = "all.target.starts")

##relabel the host genome column with the matching.host.genomes column and the the host.target.pair column
duplicate.host.genomes <- duplicate.host.genomes%>%
  ungroup()%>%
  mutate(host.acc. = matching.host.genomes)%>%
  mutate(array.id=paste(unlist(list(unique(array.id))), collapse = "$merged_"))%>%
  mutate(host.target.pair = paste(host.acc., target.acc., sep = "$"))%>%
  select(-matching.host.genomes, -spacer.acc., -assembly_accession, -unique.protospacer.host.match, -all.target.starts)

duplicate.host.genomes <- unique(duplicate.host.genomes)


dat <- duplicate.host.genomes
length(unique(dat$target.acc.))
length(unique(dat$host.acc.))
length(unique(dat$host.target.pair))


##select the hits that where there is no duplicate host genome for a target genome. Further analysis will be done to check these are not similar enough to be called duplcaites.
one.host.genome <- swipeData%>%filter(duplicate.genomes == 1)
one.host.genome <- unique(one.host.genome)


########

one.host.genome <- one.host.genome%>%
  select( -spacer.acc., -assembly_accession, -unique.protospacer.host.match, -all.target.starts)

##combine the now filtered duplicate.host.genomes with the one.host.genome
one.host.genome <- rbind(as.data.frame(one.host.genome), as.data.frame(duplicate.host.genomes))


##add unique hit information to a column 
one.host.genome <- one.host.genome%>%mutate(unique.protospacer.host.match =  paste(target.acc., target.pos, sep = "_"))



dat <- one.host.genome
length(unique(dat$target.acc.))
length(unique(dat$host.acc.))
length(unique(dat$host.target.pair))



##count the number of times a protospacer site is matched
protospacer.counts.dat <- one.host.genome%>%group_by(target.acc., unique.protospacer.host.match)%>%summarise(protospacer.freq.num = n())%>%ungroup()%>%select(-target.acc.)


##add the protospacer counts data
one.host.genome <- left_join(one.host.genome, protospacer.counts.dat, by = "unique.protospacer.host.match")
one.host.genome <- unique(one.host.genome)

##count the number of spacers that are duplicated in each host-target pair (e.g. if there are 7 matches, how many of the 7 have more than one host genome targeting each site)
spacer.counts.dat <- one.host.genome%>%filter(protospacer.freq.num > 1)%>%group_by(host.target.pair)%>%summarise(shared.protospacer.num = n())

##add the spacer counts data
one.host.genome <- left_join(one.host.genome, spacer.counts.dat, by ="host.target.pair")

##keep the host-target pairs with no duplicate spacers
no.duplicate.spacer <- one.host.genome%>%filter(is.na(shared.protospacer.num))

dat <- no.duplicate.spacer
length(unique(dat$target.acc.))
length(unique(dat$Genome))
length(unique(dat$host.target.pair))

i.e <- dat%>%filter(Subtype == "I-E")

length(unique(i.e$target.acc.))
length(unique(i.e$Genome))
length(unique(i.e$host.target.pair))

##keep the host-target pairs with only a single shared protospacer site (this should look at only the cases where the PPS is duplicated initially)
single.duplicate.spacer <- one.host.genome%>%filter(shared.protospacer.num == 1)


dat <- single.duplicate.spacer
length(unique(dat$target.acc.))
length(unique(dat$Genome))
length(unique(dat$host.target.pair))

i.e <- dat%>%filter(Subtype == "I-E")
length(unique(i.e$target.acc.))
length(unique(i.e$Genome))
length(unique(i.e$host.target.pair))

##is the PPS the duplicated spacer?
PPS.duplicate.spacer <- single.duplicate.spacer%>%filter(spacer.order.number == 1)%>%mutate(pps.spacer.duplicated = ifelse(protospacer.freq.num > 1, T, F))%>%select(host.target.pair, pps.spacer.duplicated)
single.duplicate.spacer <- left_join(single.duplicate.spacer, PPS.duplicate.spacer, by = "host.target.pair")

##select the spacers that are only duplicated at the PPS
PPS.duplicate.spacer <- single.duplicate.spacer%>%filter(pps.spacer.duplicated == T)

dat <- PPS.duplicate.spacer
length(unique(dat$target.acc.))
length(unique(dat$Genome))
length(unique(dat$host.target.pair))

i.e <- dat%>%filter(Subtype == "I-E")
length(unique(i.e$target.acc.))
length(unique(i.e$Genome))
length(unique(i.e$host.target.pair))




##select the remaining spacers
other.spacers <- one.host.genome%>%filter(shared.protospacer.num > 1)


PPS.duplicate.spacer <- PPS.duplicate.spacer%>%select(-pps.spacer.duplicated)
swipeData <- rbind(no.duplicate.spacer, PPS.duplicate.spacer)
###
write.table(swipeData, "refseq_83.swipe.hosts_nr_clustered_20-02-18.txt", sep = "\t", quote = F, row.names = F, col.names = T)


rm(duplicate.host.genomes)
rm(host.target.pair.summary)
rm(merged.host.genome.names)
rm(no.duplicate.spacer)
rm(number.of.duplicate.host.genomes)
rm(one.host.genome)
rm(other.spacers)
rm(PPS.duplicate.spacer)
rm(protospacer.counts.dat)
rm(single.duplicate.spacer)
rm(spacer.counts.dat)



##create column containing the target position, the bit score of the match and the spacer order number (should all of these be included?).
swipeData <- swipeData%>%mutate(spacer.id =  paste(spacer.number, array.id, spacer.order.number, host.acc., sep = "_"))




##combine each of the spacer.ides for each of the host target pairs so that the entire match is summarised in one column.
host.target.pair.summary <- swipeData%>%
  group_by(host.acc.,host.target.pair)%>%
  summarise(all.host.starts = paste(unlist(list(spacer.id)), collapse = ","))

host.target.pair.summary <- as.data.frame(host.target.pair.summary)



##count the number of times each of the host genomes are identical for each of the target genomes.
number.of.duplicate.target.genomes <- host.target.pair.summary%>%
  group_by(host.acc.,all.host.starts)%>%
  summarise(duplicate.targets = n())%>%
  ungroup()%>%select(-host.acc.)

##add th number of times each of the host genomes occurs to the data set containing the host.target.pair data.
host.target.pair.summary <- left_join(host.target.pair.summary, number.of.duplicate.target.genomes, by = "all.host.starts")
host.target.pair.summary <- host.target.pair.summary%>%ungroup()%>%select(-host.acc.)

##add the duplicate genomes data to the hits data
swipeData <- left_join(swipeData, host.target.pair.summary, by = "host.target.pair")
swipeData <- unique(swipeData)




####

##select the duplicated genomes
duplicate.target.genomes <- swipeData%>%filter(duplicate.targets > 1)



###check that there are still >= 2 hits per pair (there aren't for a few of them?)
tmp <- duplicate.target.genomes%>%select(host.target.pair, spacer.id)%>%distinct()%>%group_by(host.target.pair)%>%summarise(x = n())


##create a combined 'genome' name containing each of the host genome names that are duplicated for a target genome.
merged.target.genome.names <- duplicate.target.genomes%>%
  group_by(all.host.starts)%>%
  summarise(matching.target.genomes = paste(unlist(list(unique(target.acc.))), collapse = "$merged_"))

##add the matching.host.genomes to the hits data based to label the duplicate genomes by which other genomes are identical.
duplicate.target.genomes <- left_join(duplicate.target.genomes, merged.target.genome.names, by = "all.host.starts")



tt <- duplicate.target.genomes%>%ungroup()%>%
  mutate(target.acc. = matching.target.genomes)%>%
  mutate(host.target.pair = paste(host.acc., target.acc., sep = "__"))%>%
  mutate(prop.distance.to.protospacer = distance.to.protospacer/genome.length)%>%
  group_by(host.target.pair, spacer.id)%>%
  summarise(mean.protospacer.distance.prop = mean(prop.distance.to.protospacer))%>%
  mutate(merged.spacer.id = paste(host.target.pair, spacer.id, sep = "_"))%>%ungroup()%>%
  select(-host.target.pair, -spacer.id)



duplicate.target.genomes <- duplicate.target.genomes%>%
  mutate(target.acc. = matching.target.genomes)%>%
  mutate(host.target.pair = paste(host.acc., target.acc., sep = "__"))%>%
  mutate(merged.spacer.id = paste(host.target.pair, spacer.id, sep = "_"))


duplicate.target.genomes <- left_join(duplicate.target.genomes, tt, by = "merged.spacer.id")


###check that each of the spacers has only one distance.
tmp <- duplicate.target.genomes%>%select(merged.spacer.id, mean.protospacer.distance.prop)%>%distinct()%>%group_by(merged.spacer.id)%>%summarise(x = n())


duplicate.target.genomes <- duplicate.target.genomes%>%
  mutate(protospacer.distance.num.2 = mean.protospacer.distance.prop)%>%
  mutate(distance.is.averaged = ifelse(protospacer.distance.num.2 == mean.protospacer.distance.prop, T, F))

table(duplicate.target.genomes$distance.is.averaged)

#tt <- duplicate.target.genomes%>%group_by(matching.target.names)%>%


tt <- duplicate.target.genomes%>%
  group_by(merged.spacer.id)%>%
  summarise(mean.genome.length = mean(genome.length))

duplicate.target.genomes <- left_join(duplicate.target.genomes, tt, by = "merged.spacer.id")


tt <- duplicate.target.genomes%>%
  group_by(merged.spacer.id)%>%
  summarise(mean.target.pos = mean(target.pos))



duplicate.target.genomes <- left_join(duplicate.target.genomes, tt, by = "merged.spacer.id")

duplicate.target.genomes <- duplicate.target.genomes%>%ungroup()%>%
  mutate(target.acc. = matching.target.genomes)%>%
  mutate(genome.length = mean.genome.length)%>%
  mutate(target.pos = mean.target.pos)%>%
  mutate(host.target.pair = paste(host.acc., target.acc., sep = "__"))%>%
  mutate(distance.to.protospacer = round(protospacer.distance.num.2*genome.length))%>%
select(-unique.protospacer.host.match, -protospacer.freq.num, -shared.protospacer.num)
  

hits.counter <- duplicate.target.genomes%>%select(host.target.pair, merged.spacer.id)%>%distinct()%>%group_by(host.target.pair)%>%summarise(hits.count = n())

spacer.order <- duplicate.target.genomes%>%select(host.target.pair, merged.spacer.id, spacer.number)%>%distinct()%>%group_by(host.target.pair)%>%arrange(-spacer.number)%>%mutate(spacer.order.number = row_number())%>%ungroup()%>%select(merged.spacer.id, spacer.order.number)


duplicate.target.genomes <- duplicate.target.genomes%>%select(-spacer.order.number, -hits.count)

duplicate.target.genomes <- left_join(duplicate.target.genomes, hits.counter, by = "host.target.pair")
duplicate.target.genomes <- left_join(duplicate.target.genomes, spacer.order, by = "merged.spacer.id")

duplicate.target.genomes <- unique(duplicate.target.genomes)

duplicate.target.genomes <- duplicate.target.genomes%>%mutate(x = runif(nrow(duplicate.target.genomes), 0, 1))

duplicate.target.genomes <- duplicate.target.genomes%>%
  group_by(merged.spacer.id)%>%
  arrange(x)%>%
  mutate(y = row_number())%>%
  filter(y == 1)%>%
  select(-x, -y)

duplicate.target.genomes <- duplicate.target.genomes%>%
  filter(distance.is.averaged == T)%>%
  group_by(merged.spacer.id)%>%
  mutate(duplicate.count = n())





##select the target genomes that are unique
one.target.genome <- swipeData%>%filter(duplicate.targets == 1)


one.target.genome <- one.target.genome%>%select(host.target.pair, subtype.list, target.acc.,     
  host.acc.,  array.id, spacer.number,   
  target.pos, strand,  genome.length,   
 pps.strand, target.strand, distance.to.protospacer,       
 duplicate.genomes, spacer.id, all.host.starts, 
 duplicate.targets,  hits.count,      
 spacer.order.number, bit.score.num)

duplicate.target.genomes <- duplicate.target.genomes%>%ungroup()%>%select(host.target.pair, subtype.list, target.acc.,     
  host.acc.,  array.id, spacer.number,   
  target.pos, strand,  genome.length,   
 pps.strand, target.strand, distance.to.protospacer,       
 duplicate.genomes, spacer.id, all.host.starts, 
 duplicate.targets,  hits.count,      
 spacer.order.number, bit.score.num)

one.target.genome <- rbind(one.target.genome, duplicate.target.genomes)

##count the number of times a spacer matches protospacer sites
spacer.counts.dat <- one.target.genome%>%group_by(host.acc., spacer.id)%>%summarise(spacer.freq.num = n())%>%ungroup()%>%select(-host.acc.)

##add the protospacer counts data
one.target.genome <- left_join(one.target.genome, spacer.counts.dat, by = "spacer.id")
one.target.genome <- unique(one.target.genome)

##count the number of spacers that are duplicated in each host-target pair
spacer.counts.dat <- one.target.genome%>%filter(spacer.freq.num > 1)%>%group_by(host.target.pair)%>%summarise(shared.spacer.num = n())

##add the spacer counts data
one.target.genome <- left_join(one.target.genome, spacer.counts.dat, by ="host.target.pair")

##keep the host-target pairs with no duplicate spacers
no.duplicate.spacer <- one.target.genome%>%filter(is.na(shared.spacer.num))



##keep the host-target pairs with only a single shared protospacer site (this should look at only the cases where the PPS is duplicated initially)
single.duplicate.protospacer <- one.target.genome%>%filter(shared.spacer.num == 1)

##is the PPS the duplicated protospacer?
PPS.duplicate.protospacer <- single.duplicate.protospacer%>%filter(spacer.order.number == 1)%>%mutate(pps.protospacer.duplicated = ifelse(spacer.freq.num > 1, T, F))%>%select(host.target.pair, pps.protospacer.duplicated)
single.duplicate.protospacer <- left_join(single.duplicate.protospacer, PPS.duplicate.protospacer, by = "host.target.pair")

##select the spacers that are only duplicated at the PPS
PPS.duplicate.protospacer <- single.duplicate.protospacer%>%filter(pps.protospacer.duplicated == T)


write.table(PPS.duplicate.protospacer, "refseq_79.swipe.one_duplicate_pps_target", sep = "\t", quote = F, row.names = F, col.names = T)

PPS.duplicate.protospacer <- PPS.duplicate.protospacer%>%select(-pps.protospacer.duplicated)


swipeData <- rbind(no.duplicate.spacer, PPS.duplicate.protospacer)


  
  
  
  ##select the data that is not the PPS 
not.PPS.dat <- swipeData%>%filter(spacer.order.number != 1)

##select the PPS data
first.spacer.dat <- swipeData%>%filter(spacer.order.number == 1)

##calculate 5' and 3' direction
not.PPS.dat <- not.PPS.dat%>%mutate(five.three.prime.dir = ifelse(pps.strand == 1, 
                                                                  ifelse(target.strand == "t", 
                                                                         ifelse(distance.to.protospacer < 0 , "5", "3"), 
                                                                         ifelse(distance.to.protospacer < 0 , "3", "5")), 
                                                                  ifelse(target.strand == "t", 
                                                                         ifelse(distance.to.protospacer < 0 , "3", "5"), 
                                                                         ifelse(distance.to.protospacer < 0 , "5", "3"))))

first.spacer.dat <- first.spacer.dat%>%mutate(five.three.prime.dir = "0")

##combine the data
swipeData <- rbind(first.spacer.dat, not.PPS.dat)


swipeData <- swipeData%>%mutate(unique.spacer.target.match =  paste(spacer.number, array.id, spacer.order.number, host.acc., sep = "_"))%>%
  mutate(Subtype = subtype.list)%>%
  select(-subtype.list)

distances <- as.data.frame(table(swipeData$distance.to.protospacer))
colnames(distances) <- c("distance.to.protospacer", "frequency.of.distance")
distances <- distances%>%mutate(distance.to.protospacer = as.numeric(as.character(distance.to.protospacer)))


swipeData <- left_join(swipeData, distances, by = "distance.to.protospacer")

swipeData <- swipeData%>%
  mutate(keep.spacer = ifelse(spacer.order.number == 1, T, ifelse(frequency.of.distance < 4, T, F)))%>%
  filter(keep.spacer == T)%>%
  select(-keep.spacer)



#swipeData <- swipeData%>%
 # mutate(distance.to.protospacer = -distance.to.protospacer)





swipeData <- swipeData%>%filter(hits.count < 6)



rm(duplicate.target.genomes)
rm(host.target.pair.summary)
rm(merged.target.genome.names)
rm(no.duplicate.spacer)
rm(number.of.duplicate.target.genomes)
rm(one.target.genome)
rm(PPS.duplicate.protospacer)
rm(spacer.counts.dat)
rm(spacer.order)
rm(hits.counter)
rm(single.duplicate.protospacer)
rm(tmp)
rm(tt)

#####

swipeData <- swipeData%>%mutate(distance.to.protospacer = -distance.to.protospacer)%>%
  mutate(five.three.prime.dir = ifelse(pps.strand == 1, 
                                                                  ifelse(target.strand == "t", 
                                                                         ifelse(distance.to.protospacer < 0 , "5", "3"), 
                                                                         ifelse(distance.to.protospacer < 0 , "3", "5")), 
                                                                  ifelse(target.strand == "t", 
                                                                         ifelse(distance.to.protospacer < 0 , "3", "5"), 
                                                                         ifelse(distance.to.protospacer < 0 , "5", "3")))
                                )





write.table(swipeData, "refseq_83.swipe.nr.clustered_27-03-18.txt", sep = "\t", quote = F, row.names = F, col.names = T)

write.table(swipeData, "Project/CRISPR_Analysis_Shiny_App/refseq_83.swipe.nr.clustered_27-03-18.txt", sep = "\t", quote = F, row.names = F, col.names = T)
write.table(swipeData, "Project/CRISPR_Analysis_Shiny_App_Fast/refseq_83.swipe.nr.clustered_27-03-18.txt", sep = "\t", quote = F, row.names = F, col.names = T)


dat <- swipeData%>%filter(spacer.order.number > 1)

table(dat$Subtype)

#####
swipeData <-  read.table("refseq_83.swipe.nr_27-3-18.txt", comment.char = "", fill = T, sep = "\t", header = T)
clusteredData <-  read.table("refseq_83.swipe.nr.clustered_27-03-18.txt", comment.char = "", fill = T, sep = "\t", header = T)

table(swipeData$Subtype)
table(clusteredData$Subtype)


quadrant_analysis <- function(dat, Subtype.label, use.all.hits = F){
 if(use.all.hits){ 
   IFData <- dat%>%filter(Subtype == Subtype.label)%>%filter(spacer.order.number >= 2)
 }else if(use.all.hits == F){
      IFData <- dat%>%filter(Subtype == Subtype.label)%>%filter(spacer.order.number == 2 | spacer.order.number == 3)

 }
  
IFData <- IFData%>%mutate(tmp = paste(target.strand, five.three.prime.dir, sep = "_"))
quadrants <- as.data.frame(table(IFData$tmp))
total <- sum(quadrants$Freq)
quadrants <- quadrants%>%mutate(percentage = round(Freq/total*100, 2))
strands <- as.data.frame(table(IFData$target.strand))
strands <- strands%>%mutate(percentage = round(Freq/total*100, 2))
mat <- matrix(c(round(quadrants[4,2]), round(quadrants[3,2]),round(quadrants[1,2]), round(quadrants[2,2]) ), nrow = 2, byrow = T)
   # mat <- matrix(c(38,28,17,31), nrow = 2, byrow = T)
mat.res <- fisher.test(mat)
quadrants <- quadrants%>%mutate(rowNum = c(3,4,1,2))%>%arrange(rowNum)%>%select(-rowNum)
print(paste("Host-Target pairs:", length(unique(IFData$host.target.pair))))
print(paste("Quadrant p-value:",round(mat.res$p.value, 4)))
print(strands)
print(quadrants)

}
quadrant_analysis(dat = swipeData, Subtype.label = "II-A", use.all.hits = F)



```

Writes files for Prism 
```{r analysis_output}
##import the full dataset
swipeData <- read.table("refseq_83.swipe.nr_27-3-18.txt", comment.char = "", fill = T, sep = "\t", header = T)
    
##include a strand and direction column
swipeData <- swipeData%>%mutate(strand.plus.direction = paste(target.strand, five.three.prime.dir, sep = "_"))
    
##Add legend labels to the dataset using the strand and direction
swipeData <- swipeData%>%mutate(legend.labels = ifelse(strand.plus.direction == "n_3", "Non-target 3' direction", ifelse(strand.plus.direction == "n_5", "Non-target 5' direction",ifelse(strand.plus.direction == "t_3", "Target 3' direction", "Target 5' direction"))))
    
##import the clustered dataset
clusteredData <- read.table("refseq_83.swipe.nr.clustered_27-03-18.txt", comment.char = "", fill = T, sep = "\t", header = T)

##include a strand and direction column
clusteredData <- clusteredData%>%mutate(strand.plus.direction = paste(target.strand, five.three.prime.dir, sep = "_"))
    
##Add legend labels to the dataset using the strand and direction
clusteredData <- clusteredData%>%mutate(legend.labels = ifelse(strand.plus.direction == "n_3", "Non-target 3' direction", ifelse(strand.plus.direction == "n_5", "Non-target 5' direction",ifelse(strand.plus.direction == "t_3", "Target 3' direction", "Target 5' direction"))))
    
rh <- generate_random_distribution(swipeData = swipeData)
rh <- generate_random_quadrants(swipeData = swipeData)

subtypes <- c("I-B", "I-C", "I-E", "I-F", "II-A", "II-C")
i <- "I-F"
for(i in subtypes){
den <- protospacer_distribution(swipeData = swipeData, rh = rh, Subtype.label = i)
hits <- prism_format_protospacer_distribution(den = den)
hits <- noramlise_distribution_values(hits)
 write.csv(hits, file = paste(i, "_standard.csv", sep = ""), row.names = FALSE)

}

######
quadrant_analysis(dat = clusteredData, Subtype.label = "I-F", use.all.hits = F)

```

```{r statistical_analysis}
## Clustering of protospacers in the whole subtype
swipeData <- read.table("refseq_83.swipe.nr_27-3-18.txt", comment.char = "", fill = T, sep = "\t", header = T)

##include a strand and direction column
swipeData <- swipeData%>%mutate(strand.plus.direction = paste(target.strand, five.three.prime.dir, sep = "_"))
    
##Add legend labels to the dataset using the strand and direction
swipeData <- swipeData%>%mutate(legend.labels = ifelse(strand.plus.direction == "n_3", "Non-target 3' direction", ifelse(strand.plus.direction == "n_5", "Non-target 5' direction",ifelse(strand.plus.direction == "t_3", "Target 3' direction", "Target 5' direction"))))

##import the clustered dataset
clusteredData <- read.table("refseq_83.swipe.nr.clustered_27-03-18.txt", comment.char = "", fill = T, sep = "\t", header = T)

##include a strand and direction column
clusteredData <- clusteredData%>%mutate(strand.plus.direction = paste(target.strand, five.three.prime.dir, sep = "_"))
    
##Add legend labels to the dataset using the strand and direction
clusteredData <- clusteredData%>%mutate(legend.labels = ifelse(strand.plus.direction == "n_3", "Non-target 3' direction", ifelse(strand.plus.direction == "n_5", "Non-target 5' direction",ifelse(strand.plus.direction == "t_3", "Target 3' direction", "Target 5' direction"))))
    
cluster_analysis(swipeData = swipeData)

rh <- generate_random_distribution(swipeData = swipeData)



ks_test_analysis(swipeData = clusteredData, rh = rh, Subtype.label = "II-C")


quadrant_analysis <- function(dat, Subtype.label, use.all.hits = F){
 if(use.all.hits){ 
   IFData <- dat%>%filter(Subtype == Subtype.label)%>%filter(spacer.order.number >= 2)
 }else if(use.all.hits == F){
      IFData <- dat%>%filter(Subtype == Subtype.label)%>%filter(spacer.order.number == 2 | spacer.order.number == 3)
 }
  
IFData <- IFData%>%mutate(tmp = paste(target.strand, five.three.prime.dir, sep = "_"))
quadrants <- as.data.frame(table(IFData$tmp))
total <- sum(quadrants$Freq)
quadrants <- quadrants%>%mutate(percentage = round(Freq/total*100, 2))
strands <- as.data.frame(table(IFData$target.strand))
strands <- strands%>%mutate(percentage = round(Freq/total*100, 2))
mat <- matrix(c(round(quadrants[4,2]), round(quadrants[3,2]),round(quadrants[1,2]), round(quadrants[2,2]) ), nrow = 2, byrow = T)
   # mat <- matrix(c(38,28,17,31), nrow = 2, byrow = T)

 # mat.res <- fisher.test(mat)
quadrants <- quadrants%>%mutate(rowNum = c(3,4,1,2))%>%arrange(rowNum)%>%select(-rowNum)
 mat.res <- multinomial.test(observed = quadrants$Freq, prob = c(0.25, 0.25, 0.25, 0.25), MonteCarlo = T, ntrial = 10000000)


print(paste("Host-Target pairs:", length(unique(IFData$host.target.pair))))
print(paste("Quadrant p-value:",round(mat.res$p.value, 4)))
# print(mat.res$p.value)
print(strands)
print(quadrants)

outputMat <- matrix(c(quadrants[c(2,4,1,3), 3], strands[c(2,1),3],  length(unique(IFData$host.target.pair)), mat.res$p.value), ncol = 2, byrow = T)


 write.csv(outputMat, file = paste(i, "_quadrant.csv", sep = ""), row.names = FALSE)


}

subtypes <- c("I-B", "I-C", "I-E", "I-F", "II-A", "II-C")
for(i in subtypes){
quadrant_analysis(dat = swipeData, Subtype.label = i, use.all.hits = T)
}
```
